<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quiz Buzzer System</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'SF Pro Display', 'SF Pro Text', -apple-system, BlinkMacSystemFont, system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
      color: #1d1d1f;
      overflow: hidden;
    }
    
    /* Top Navigation */
    .top-nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px;
      z-index: 100;
    }
    
    .nav-button {
      width: 44px;
      height: 44px;
      border-radius: 22px;
      border: none;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(20px);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }
    
    .nav-button:hover {
      background: rgba(255, 255, 255, 0.9);
      transform: scale(1.05);
    }
    
    .nav-button:active {
      transform: scale(0.95);
    }
    
    /* Connection Status */
    .connection-status {
      position: relative;
    }
    
    .status-dot {
      position: absolute;
      top: -2px;
      right: -2px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff3b30;
      border: 2px solid white;
      transition: all 0.3s ease;
    }
    
    .status-dot.connected {
      background: #30d158; /* Green - device ready and working */
    }
    
    .status-dot.connecting {
      background: #ff9500; /* Orange/Yellow - device connected but not responding */
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* Main Content */
    .main-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 100px 24px 50px;
    }
    
    /* Team Name Display */
    .team-name {
      font-size: 72px;
      font-weight: 700;
      color: #1d1d1f;
      margin-bottom: 50px;
      opacity: 0;
      transform: translateY(30px);
      transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      text-align: center;
      min-height: 80px;
      letter-spacing: 1px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      z-index: 1000; /* Ensure it's always on top */
      position: relative;
    }
    
    .team-name.visible {
      opacity: 1;
      transform: translateY(0);
      animation: teamNameSlideIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    /* Bouncing Team System */
    .bouncing-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      overflow: hidden;
    }
    
    .team-bouncer {
      position: absolute;
      width: 170px;
      height: 170px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease, transform 0.4s ease;
      opacity: 1;
      z-index: 10;
      border: 3px solid rgba(255, 255, 255, 0.6);
    }
    
    .team-bouncer.winner-entering {
      transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      transform: scale(0.6);
      z-index: 15;
    }
    
    .team-bouncer.winner-positioned {
      transform: scale(0.8);
      z-index: 5; /* Lower than main circle content but visible inside */
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
      border: 3px solid rgba(255, 255, 255, 0.6);
    }
    

    

    
    .team-bouncer.winner-celebrating {
      animation: winnerCelebration 0.3s ease-out;
      z-index: 16;
    }
    
    @keyframes winnerCelebration {
      0% { 
        transform: scale(1); 
      }
      50% { 
        transform: scale(1.3) rotate(5deg); 
        box-shadow: 0 10px 40px rgba(0, 122, 255, 0.6);
      }
      100% { 
        transform: scale(1.1); 
        box-shadow: 0 8px 35px rgba(0, 122, 255, 0.4);
      }
    }
    
    .team-bouncer.winner-exiting {
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 15;
    }
    
    .team-bouncer.winner-launching {
      animation: winnerLaunch 0.2s ease-out;
      z-index: 16;
    }
    
    @keyframes winnerLaunch {
      0% { 
        transform: scale(0.3); 
      }
      60% { 
        transform: scale(0.5) rotate(-3deg); 
        box-shadow: 0 8px 30px rgba(0, 122, 255, 0.5);
      }
      100% { 
        transform: scale(0.4); 
      }
    }
    
    .team-bouncer.hidden {
      opacity: 0;
      transform: scale(0.3);
      pointer-events: none;
    }
    
    .team-bouncer-number {
      font-size: 56px;
      font-weight: 700;
      color: white;
      text-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
      line-height: 1;
      margin-bottom: 6px;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .team-bouncer-name {
      font-size: 22px;
      font-weight: 700;
      color: white;
      text-shadow: 0 3px 8px rgba(0, 0, 0, 0.8);
      text-align: center;
      max-width: 160px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.1;
      padding: 0 12px;
      letter-spacing: 0.5px;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    /* Center Exclusion Zone */
    .center-zone {
      position: absolute;
      width: 600px;
      height: 600px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      pointer-events: none;
      z-index: 5;
    }
    
    /* Main Circle */
    .main-circle {
      width: 480px;
      height: 480px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      margin-bottom: 60px;
      z-index: 10; /* Above positioned winner team */
    }
    
    .main-circle.winner {
      background: linear-gradient(135deg, #007aff 0%, #5856d6 50%, #af52de 100%);
      transform: scale(1.15);
      box-shadow: 0 20px 60px rgba(0, 122, 255, 0.4), 0 0 0 4px rgba(255, 255, 255, 0.3);
      animation: winnerPulse 1.5s ease-in-out infinite alternate;
    }
    
    .circle-content {
      font-size: 220px;
      font-weight: 700;
      color: #8e8e93;
      transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      line-height: 1;
      text-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      position: relative;
      z-index: 15; /* Above everything including positioned winner */
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .circle-content.winner-number {
      color: white;
      font-size: 280px;
      text-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      animation: numberBounce 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .circle-content.waiting {
      animation: breathe 2s ease-in-out infinite;
    }
    
    @keyframes breathe {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }
    
    @keyframes winnerPulse {
      0% { 
        box-shadow: 0 20px 60px rgba(0, 122, 255, 0.4), 0 0 0 4px rgba(255, 255, 255, 0.3);
      }
      100% { 
        box-shadow: 0 25px 80px rgba(0, 122, 255, 0.6), 0 0 0 8px rgba(255, 255, 255, 0.5);
      }
    }
    
    @keyframes numberBounce {
      0% { 
        transform: scale(0.3) rotate(-10deg); 
        opacity: 0; 
      }
      50% { 
        transform: scale(1.1) rotate(2deg); 
      }
      70% { 
        transform: scale(0.95) rotate(-1deg); 
      }
      100% { 
        transform: scale(1) rotate(0deg); 
        opacity: 1; 
      }
    }
    
    @keyframes celebrationBurst {
      0% { 
        transform: scale(0) rotate(0deg); 
        opacity: 1; 
      }
      50% { 
        transform: scale(1.5) rotate(180deg); 
        opacity: 0.8; 
      }
      100% { 
        transform: scale(3) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    @keyframes teamNameSlideIn {
      0% { 
        transform: translateY(50px) scale(0.8); 
        opacity: 0; 
      }
      60% { 
        transform: translateY(-10px) scale(1.05); 
        opacity: 1; 
      }
      100% { 
        transform: translateY(0) scale(1); 
        opacity: 1; 
      }
    }
    
    /* Reset Button */
    .reset-button {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(20px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      opacity: 0;
      transform: translateY(20px);
      font-size: 24px;
    }
    
    .reset-button.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .reset-button:hover {
      background: rgba(255, 255, 255, 1);
      transform: translateY(0) scale(1.1);
    }
    
    .reset-button:active {
      transform: translateY(0) scale(0.95);
    }
    
    /* Settings Modal */
    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease;
    }
    
    .settings-modal.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    .settings-content {
      background: white;
      border-radius: 20px;
      padding: 32px;
      max-width: 480px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      transform: scale(0.9) translateY(20px);
      transition: all 0.3s ease;
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.2);
    }
    
    .settings-modal.visible .settings-content {
      transform: scale(1) translateY(0);
    }
    
    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }
    
    .settings-title {
      font-size: 32px;
      font-weight: 600;
      color: #1d1d1f;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .close-button {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: none;
      background: #f2f2f7;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 16px;
      color: #8e8e93;
    }
    
    .close-button:hover {
      background: #e5e5ea;
    }
    
    /* Team Input */
    .team-input-group {
      margin-bottom: 16px;
    }
    
    .team-label {
      display: block;
      font-size: 18px;
      font-weight: 500;
      color: #1d1d1f;
      margin-bottom: 8px;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .team-input-container {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .team-color-picker {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      border: 2px solid #e5e5ea;
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
      background: #f2f2f7;
      overflow: hidden;
    }
    
    .team-color-picker:hover {
      transform: scale(1.05);
      border-color: #007aff;
    }
    
    .team-color-picker input[type="color"] {
      width: 100%;
      height: 100%;
      border: none;
      cursor: pointer;
      background: transparent;
    }
    
    .team-input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #e5e5ea;
      border-radius: 12px;
      font-size: 20px;
      background: white;
      transition: all 0.2s ease;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .team-input:focus {
      outline: none;
      border-color: #007aff;
      box-shadow: 0 0 0 4px rgba(0, 122, 255, 0.1);
    }
    
    /* Settings Actions */
    .settings-actions {
      margin-top: 24px;
      padding-top: 20px;
      border-top: 1px solid #e5e5ea;
      display: flex;
      gap: 12px;
    }
    
    .settings-button {
      flex: 1;
      padding: 14px 24px;
      border: none;
      border-radius: 10px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .settings-button.primary {
      background: #007aff;
      color: white;
    }
    
    .settings-button.primary:hover {
      background: #0056cc;
    }
    
    .settings-button.secondary {
      background: #f2f2f7;
      color: #8e8e93;
    }
    
    .settings-button.secondary:hover {
      background: #e5e5ea;
      color: #1d1d1f;
    }
    
        /* Connection Modal */
    .connection-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 300;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease;
    }

    .connection-modal.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .connection-content {
      background: white;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.2);
      text-align: center;
      min-width: 300px;
      transform: scale(0.9) translateY(20px);
      transition: all 0.3s ease;
    }

    .connection-modal.visible .connection-content {
      transform: scale(1) translateY(0);
    }
    
    .connection-modal h3 {
      font-size: 26px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #1d1d1f;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .connection-modal p {
      font-size: 20px;
      color: #8e8e93;
      margin-bottom: 20px;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .connect-button {
      background: #007aff;
      color: white;
      border: none;
      border-radius: 12px;
      padding: 14px 28px;
      font-size: 20px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-right: 12px;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .connect-button:hover {
      background: #0056cc;
    }
    
    .cancel-button {
      background: #f2f2f7;
      color: #1d1d1f;
      border: none;
      border-radius: 12px;
      padding: 14px 28px;
      font-size: 20px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    
    .cancel-button:hover {
      background: #e5e5ea;
    }
    
    /* Celebration Effects */
    .celebration-particle {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
    }
    
    .celebration-particle.burst {
      animation: celebrationBurst 1.2s ease-out forwards;
    }
    
    .confetti {
      position: absolute;
      width: 8px;
      height: 8px;
      background: linear-gradient(45deg, #FFD700, #FFA500);
      transform: rotate(45deg);
      pointer-events: none;
      opacity: 0;
    }
    
    .confetti.fall {
      animation: confettiFall 2s ease-out forwards;
    }
    
    @keyframes confettiFall {
      0% { 
        transform: translateY(-50px) rotate(0deg) scale(0); 
        opacity: 1; 
      }
      50% { 
        transform: translateY(200px) rotate(180deg) scale(1); 
        opacity: 0.8; 
      }
      100% { 
        transform: translateY(400px) rotate(360deg) scale(0.5); 
        opacity: 0; 
      }
    }
    
    /* Screen Flash Effect */
    .screen-flash {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle, rgba(255, 215, 0, 0.3) 0%, transparent 70%);
      pointer-events: none;
      opacity: 0;
      z-index: 50;
    }
    
    .screen-flash.active {
      animation: screenFlash 0.6s ease-out;
    }
    
    @keyframes screenFlash {
      0% { opacity: 0; }
      30% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .center-zone {
        width: 500px;
        height: 500px;
      }
      
      .team-bouncer {
        width: 140px;
        height: 140px;
      }
      
      .team-bouncer-number {
        font-size: 48px;
      }
      
      .team-bouncer-name {
        font-size: 20px;
        max-width: 130px;
      }
      
      .main-circle {
        width: 380px;
        height: 380px;
      }
      
      .circle-content {
        font-size: 170px;
      }
      
      .circle-content.winner-number {
        font-size: 220px;
      }
      
      .team-name {
        font-size: 56px;
      }
    }
    
    @media (max-width: 480px) {
      .center-zone {
        width: 400px;
        height: 400px;
      }
      
      .team-bouncer {
        width: 120px;
        height: 120px;
      }
      
      .team-bouncer-number {
        font-size: 40px;
      }
      
      .team-bouncer-name {
        font-size: 18px;
        max-width: 110px;
      }
      
      .main-circle {
        width: 320px;
        height: 320px;
      }
      
      .circle-content {
        font-size: 140px;
      }
      
      .circle-content.winner-number {
        font-size: 180px;
      }
      
      .team-name {
        font-size: 48px;
      }
    }
  </style>
</head>
<body>
  <!-- Top Navigation -->
  <div class="top-nav">
    <div class="connection-status">
      <button class="nav-button" id="connectionBtn">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M1.42 9a16 16 0 0 1 21.16 0"></path>
          <path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path>
          <path d="M12 20h.01"></path>
        </svg>
      </button>
      <div class="status-dot" id="statusDot"></div>
    </div>
  
    <button class="nav-button" id="settingsBtn">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"></path>
      </svg>
          </button>
    </div>
  
  <!-- Screen Flash Effect -->
  <div class="screen-flash" id="screenFlash"></div>

  <!-- Main Content -->
  <div class="main-content">
    <div class="team-name" id="teamName"></div>
    
    <!-- Bouncing Team System -->
    <div class="bouncing-container" id="bouncingContainer">
      <!-- Team bouncer circles will be generated here -->
            </div>
            
    <!-- Center Exclusion Zone (invisible) -->
    <div class="center-zone" id="centerZone"></div>
    
    <div class="main-circle" id="mainCircle">
      <div class="circle-content waiting" id="circleContent">â€¢</div>
      <!-- Celebration particles will be added here dynamically -->
            </div>
            
    <button class="reset-button" id="resetBtn">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="23 4 23 10 17 10"></polyline>
        <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
      </svg>
    </button>
          </div>
          
  <!-- Settings Modal -->
  <div class="settings-modal" id="settingsModal">
    <div class="settings-content">
      <div class="settings-header">
        <h2 class="settings-title">Team Names</h2>
        <button class="close-button" id="closeSettings">Ã—</button>
    </div>
  
      <div id="teamInputs">
        <!-- Team inputs will be generated here -->
    </div>
    
      <div class="settings-actions">
        <button class="settings-button secondary" id="resetAllSettings">Reset All to Default</button>
        <button class="settings-button primary" id="saveSettings">Save Changes</button>
            </div>
            </div>
            </div>

  <!-- Connection Modal -->
  <div class="connection-modal" id="connectionModal">
    <div class="connection-content">
      <h3>Connect Arduino Buzzer System</h3>
      <p>Connect your Arduino/ESP32 device via USB cable</p>
      <div style="font-size: 16px; color: #666; margin: 15px 0; text-align: left; line-height: 1.4;">
        <strong>Before connecting:</strong><br>
        â€¢ Upload the buzzer code to your Arduino<br>
        â€¢ Set baud rate to 9600 in Arduino IDE<br>
        â€¢ Close Arduino IDE Serial Monitor<br>
        â€¢ Make sure USB cable is connected properly
      </div>
      <button class="connect-button" id="connectDeviceBtn">Connect Arduino</button>
      <button class="cancel-button" id="cancelConnect">Use Simulation Mode</button>
    </div>
  </div>
  
  <script>
    // Global variables
    let port, reader, serialWriter;
    let isConnected = false;
    let isDeviceReady = false; // New: tracks if device is actually working
    let connectionHealth = 0; // Track connection health (0-100)
    let lastDataReceived = 0; // Timestamp of last data
    let currentWinner = null;
    let animationFrameId = null;
    let teamBouncers = [];
    let winnerAnimating = false;
    
    // Default team colors (fresh and vibrant)
    const defaultTeamColors = {
      1: '#FF3B82', // Hot Pink
      2: '#06D6A0', // Fresh Mint
      3: '#118AB2', // Ocean Blue
      4: '#7209B7', // Electric Purple
      5: '#F77F00', // Bright Orange
      6: '#FCBF49'  // Golden Yellow
    };
    
    // Enhanced bouncing system configuration with realistic physics
    function getBouncingConfig() {
      const isMobile = window.innerWidth <= 480;
      const isTablet = window.innerWidth <= 768;
      
      if (isMobile) {
        return {
          speed: 3.5,              // Billiard ball speed (mobile)
          maxSpeed: 7.0,           // Fast like cue ball
          minSpeed: 1.5,           // Always moving
          centerCircleRadius: 180, // Circle collision radius
          centerZoneRadius: 200,   // Safety zone
          cornerBuffer: 40,        // Edge buffer
          teamSize: 120,
          restitution: 0.95,       // Slightly less bouncy for realism
          tableFriction: 0.9995    // Very minimal table friction
        };
      } else if (isTablet) {
        return {
          speed: 3.8,              // Billiard ball speed (tablet)
          maxSpeed: 7.5,           // Fast like cue ball
          minSpeed: 1.8,           // Always moving
          centerCircleRadius: 210,
          centerZoneRadius: 250,
          cornerBuffer: 50,
          teamSize: 140,
          restitution: 0.95,       // Slightly less bouncy for realism
          tableFriction: 0.9995    // Very minimal table friction
        };
      } else {
        return {
          speed: 4.0,              // Billiard ball speed
          maxSpeed: 8.0,           // Fast like cue ball
          minSpeed: 2.0,           // Always moving
          centerCircleRadius: 240, // Main circle collision radius
          centerZoneRadius: 300,   // Safety zone
          cornerBuffer: 60,
          teamSize: 170,
          restitution: 0.95,       // Slightly less bouncy for realism
          tableFriction: 0.9995    // Very minimal table friction
        };
      }
    }
    
    // DOM elements
    const connectionBtn = document.getElementById('connectionBtn');
    const statusDot = document.getElementById('statusDot');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const connectionModal = document.getElementById('connectionModal');
    const closeSettings = document.getElementById('closeSettings');
    const teamName = document.getElementById('teamName');
    const mainCircle = document.getElementById('mainCircle');
    const circleContent = document.getElementById('circleContent');
    const resetBtn = document.getElementById('resetBtn');
    const connectDeviceBtn = document.getElementById('connectDeviceBtn');
    const cancelConnect = document.getElementById('cancelConnect');
    const teamInputs = document.getElementById('teamInputs');

    // Initialize team inputs with color pickers
    function initializeTeamInputs() {
      teamInputs.innerHTML = '';
      for (let i = 1; i <= 6; i++) {
        const group = document.createElement('div');
        group.className = 'team-input-group';
        
        const label = document.createElement('label');
        label.className = 'team-label';
        label.textContent = `Team ${i}`;
        
        const container = document.createElement('div');
        container.className = 'team-input-container';
        
        // Color picker
        const colorPicker = document.createElement('div');
        colorPicker.className = 'team-color-picker';
        
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.id = `team${i}Color`;
        colorInput.value = getTeamColor(i);
        
        // Save color on change
        colorInput.addEventListener('change', () => {
          localStorage.setItem(`team${i}Color`, colorInput.value);
          updateBouncerTeamColor(i, colorInput.value);
        });
        
        colorPicker.appendChild(colorInput);
        
        // Team name input
        const input = document.createElement('input');
        input.className = 'team-input';
        input.type = 'text';
        input.id = `team${i}Input`;
        input.placeholder = `Team ${i}`;
        input.value = localStorage.getItem(`team${i}Name`) || '';
        
        // Save on input
        input.addEventListener('input', () => {
          localStorage.setItem(`team${i}Name`, input.value);
          updateBouncerTeamName(i, input.value || `Team ${i}`);
        });
        
        container.appendChild(colorPicker);
        container.appendChild(input);
        group.appendChild(label);
        group.appendChild(container);
        teamInputs.appendChild(group);
      }
    }
    
    // Get team color (saved or default)
    function getTeamColor(num) {
      const saved = localStorage.getItem(`team${num}Color`);
      return saved || defaultTeamColors[num];
    }
    
    // Initialize bouncing team system
    function initializeBouncingSystem() {
      const bouncingContainer = document.getElementById('bouncingContainer');
      bouncingContainer.innerHTML = '';
      teamBouncers = [];
      
      for (let i = 1; i <= 6; i++) {
        const teamBouncer = document.createElement('div');
        teamBouncer.className = 'team-bouncer';
        teamBouncer.setAttribute('data-team', i);
        teamBouncer.style.background = getTeamColor(i);
        
        const number = document.createElement('div');
        number.className = 'team-bouncer-number';
        number.textContent = i;
        
        const name = document.createElement('div');
        name.className = 'team-bouncer-name';
        name.textContent = getTeamName(i);
        
        teamBouncer.appendChild(number);
        teamBouncer.appendChild(name);
        bouncingContainer.appendChild(teamBouncer);
        
        // Initialize with billiard ball physics
        const config = getBouncingConfig();
        const position = getRandomPosition();
        
        // Random angle for billiard-style initial velocity
        const angle = Math.random() * Math.PI * 2;
        const initialSpeed = config.speed + Math.random() * (config.maxSpeed - config.speed) * 0.5;
        
        const bouncer = {
          element: teamBouncer,
          teamNum: i,
          x: position.x,
          y: position.y,
          vx: Math.cos(angle) * initialSpeed,  // Clean directional velocity
          vy: Math.sin(angle) * initialSpeed,  // Clean directional velocity
          visible: true
        };
        
        teamBouncers.push(bouncer);
        
        // Set initial position using transform for hardware acceleration
        teamBouncer.style.position = 'absolute';
        teamBouncer.style.left = '0px';
        teamBouncer.style.top = '0px';
        teamBouncer.style.transform = `translate(${bouncer.x}px, ${bouncer.y}px) scale(1)`;
        teamBouncer.style.zIndex = '10';
        teamBouncer.dataset.scale = '1'; // Track scale for updates
        
        updateBouncerPosition(bouncer);
      }
      
      startBouncing();
    }
    
    // Get random position avoiding center and corners
    function getRandomPosition() {
      const config = getBouncingConfig();
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const centerX = screenWidth / 2;
      const centerY = screenHeight / 2;
      const buffer = config.cornerBuffer;
      const teamSize = config.teamSize;
      
      let x, y;
      let attempts = 0;
      
      do {
        x = buffer + Math.random() * (screenWidth - 2 * buffer - teamSize);
        y = buffer + Math.random() * (screenHeight - 2 * buffer - teamSize);
        attempts++;
      } while (
        attempts < 50 && 
        isInCenterCircle(x + teamSize/2, y + teamSize/2)
      );
      
      return { x, y };
    }
    
    // Check if position is in center circle collision area
    function isInCenterCircle(x, y) {
      const config = getBouncingConfig();
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const distance = Math.sqrt(
        Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
      );
      return distance < (config.centerCircleRadius + config.teamSize / 2);
    }
    
    // Precise center circle collision (billiard ball physics)
    function checkCenterCircleCollision(bouncer) {
      const config = getBouncingConfig();
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const centerX = screenWidth / 2;
      const centerY = screenHeight / 2;
      const teamRadius = config.teamSize / 2;
      
      // Team center position
      const teamCenterX = bouncer.x + teamRadius;
      const teamCenterY = bouncer.y + teamRadius;
      
      // Distance from team center to circle center
      const dx = teamCenterX - centerX;
      const dy = teamCenterY - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Collision distance (circle radius + team radius)
      const collisionDistance = config.centerCircleRadius + teamRadius;
      
      // Only collide when team is inside or touching the circle
      if (distance <= collisionDistance && distance > 0) {
        // Calculate collision normal (direction from circle center to team center)
        const normalX = dx / distance;
        const normalY = dy / distance;
        
        // Push team outside the circle to the exact boundary
        const targetDistance = collisionDistance + 2; // Small buffer to prevent sticking
        const newTeamCenterX = centerX + normalX * targetDistance;
        const newTeamCenterY = centerY + normalY * targetDistance;
        bouncer.x = newTeamCenterX - teamRadius;
        bouncer.y = newTeamCenterY - teamRadius;
        
        // Calculate velocity component along collision normal
        const dotProduct = bouncer.vx * normalX + bouncer.vy * normalY;
        
        // Only reflect if moving toward circle center (prevent double bouncing)
        if (dotProduct < 0) {
          // Perfect elastic reflection
          bouncer.vx -= 2 * dotProduct * normalX * config.restitution;
          bouncer.vy -= 2 * dotProduct * normalY * config.restitution;
        }
        
        return true; // Collision occurred
      }
      return false;
    }
    
    // Precise billiard ball collision system
    function checkTeamCollisions() {
      const config = getBouncingConfig();
      const teamRadius = config.teamSize / 2;
      const collisionDistance = teamRadius * 2; // Exact touching distance
      
      for (let i = 0; i < teamBouncers.length; i++) {
        const bouncer1 = teamBouncers[i];
        if (!bouncer1.visible) continue;
        
        for (let j = i + 1; j < teamBouncers.length; j++) {
          const bouncer2 = teamBouncers[j];
          if (!bouncer2.visible) continue;
          
          // Calculate distance between centers
          const dx = (bouncer1.x + teamRadius) - (bouncer2.x + teamRadius);
          const dy = (bouncer1.y + teamRadius) - (bouncer2.y + teamRadius);
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Only collide when actually touching (not before)
          if (distance <= collisionDistance && distance > 0) {
            // Collision normal (direction from bouncer2 to bouncer1)
            const normalX = dx / distance;
            const normalY = dy / distance;
            
            // Separate objects to prevent overlap
            const overlap = collisionDistance - distance;
            if (overlap > 0) {
              const separation = overlap / 2;
              bouncer1.x += normalX * separation;
              bouncer1.y += normalY * separation;
              bouncer2.x -= normalX * separation;
              bouncer2.y -= normalY * separation;
            }
            
            // Calculate relative velocity
            const relativeVx = bouncer1.vx - bouncer2.vx;
            const relativeVy = bouncer1.vy - bouncer2.vy;
            
            // Velocity component along collision normal
            const velocityAlongNormal = relativeVx * normalX + relativeVy * normalY;
            
            // Only resolve if objects are moving toward each other
            if (velocityAlongNormal > 0) continue;
            
            // Perfect elastic collision (billiard ball physics)
            const restitution = config.restitution;
            const impulse = -(1 + restitution) * velocityAlongNormal / 2; // Equal masses
            
            // Apply impulse to both objects
            bouncer1.vx += impulse * normalX;
            bouncer1.vy += impulse * normalY;
            bouncer2.vx -= impulse * normalX;
            bouncer2.vy -= impulse * normalY;
          }
        }
      }
    }
    
    // Optimized position update using transform for better performance
    function updateBouncerPosition(bouncer) {
      if (bouncer.element && bouncer.visible) {
        // Use transform instead of left/top for hardware acceleration, preserve scale
        const currentScale = bouncer.element.dataset.scale || '1';
        bouncer.element.style.transform = `translate(${bouncer.x}px, ${bouncer.y}px) scale(${currentScale})`;
      }
    }
    
    // Reset team element to clean state
    function resetTeamElement(bouncer) {
      bouncer.element.classList.remove('winner-entering', 'winner-exiting', 'winner-celebrating', 'winner-launching', 'winner-positioned', 'hidden');
      bouncer.element.style.transition = '';
      bouncer.element.style.opacity = '1';
      bouncer.element.style.display = 'flex';
      bouncer.element.style.position = 'absolute';
      bouncer.element.style.left = '0px';
      bouncer.element.style.top = '0px';
      bouncer.element.style.zIndex = '10';
      bouncer.element.style.boxShadow = ''; // Clear any special glow effects
      bouncer.element.style.animation = ''; // Clear any ongoing animations
      bouncer.element.style.border = ''; // Clear any custom borders
      bouncer.element.dataset.scale = '1'; // Reset scale tracking
      bouncer.visible = true;
      
      // Update position with proper transform
      updateBouncerPosition(bouncer);
    }
    
    // Optimized animation system with throttling
    let lastFrameTime = 0;
    const TARGET_FPS = 60;
    const FRAME_INTERVAL = 1000 / TARGET_FPS;
    
    // Start bouncing animation
    function startBouncing() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      lastFrameTime = performance.now();
      
      function animate(currentTime) {
        // Throttle to target FPS for consistent performance
        const deltaTime = currentTime - lastFrameTime;
        
        if (deltaTime >= FRAME_INTERVAL) {
          const config = getBouncingConfig();
          let needsUpdate = false;
          
          teamBouncers.forEach(bouncer => {
            if (!bouncer.visible) return;
            
            // Update position with current velocity
            const oldX = bouncer.x;
            const oldY = bouncer.y;
            bouncer.x += bouncer.vx;
            bouncer.y += bouncer.vy;
            
            // Track if position actually changed
            if (Math.abs(bouncer.x - oldX) > 0.1 || Math.abs(bouncer.y - oldY) > 0.1) {
              needsUpdate = true;
            }
          
            // Screen boundaries for bouncing
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const buffer = config.cornerBuffer;
            const teamSize = config.teamSize;
            
            // Perfect billiard ball boundary collisions
            let bounced = false;
            
            // Left and right boundaries - perfect elastic reflection
            if (bouncer.x <= buffer) {
              bouncer.x = buffer + 1;
              if (bouncer.vx < 0) {
                bouncer.vx = -bouncer.vx * config.restitution; // Perfect reflection
              }
              bounced = true;
            } else if (bouncer.x >= screenWidth - buffer - teamSize) {
              bouncer.x = screenWidth - buffer - teamSize - 1;
              if (bouncer.vx > 0) {
                bouncer.vx = -bouncer.vx * config.restitution; // Perfect reflection
              }
              bounced = true;
            }
            
            // Top and bottom boundaries - perfect elastic reflection
            if (bouncer.y <= buffer) {
              bouncer.y = buffer + 1;
              if (bouncer.vy < 0) {
                bouncer.vy = -bouncer.vy * config.restitution; // Perfect reflection
              }
              bounced = true;
            } else if (bouncer.y >= screenHeight - buffer - teamSize) {
              bouncer.y = screenHeight - buffer - teamSize - 1;
              if (bouncer.vy > 0) {
                bouncer.vy = -bouncer.vy * config.restitution; // Perfect reflection
              }
              bounced = true;
            }
            
            // Check collision with center circle (treat as solid object)
            checkCenterCircleCollision(bouncer);
            
            // Apply minimal billiard ball physics
            
            // 1. Very minimal table friction (like smooth billiard table)
            bouncer.vx *= config.tableFriction;
            bouncer.vy *= config.tableFriction;
            
            // 2. Speed limits only - no artificial slowing
            const currentSpeed = Math.sqrt(bouncer.vx * bouncer.vx + bouncer.vy * bouncer.vy);
            
            // Cap maximum speed only (prevent runaway velocities)
            if (currentSpeed > config.maxSpeed) {
              const scale = config.maxSpeed / currentSpeed;
              bouncer.vx *= scale;
              bouncer.vy *= scale;
            }
            
            // Maintain minimum speed only if nearly stopped
            else if (currentSpeed < 0.1) {
              const angle = Math.random() * Math.PI * 2;
              bouncer.vx = Math.cos(angle) * config.minSpeed;
              bouncer.vy = Math.sin(angle) * config.minSpeed;
            }
          });
          
          // Check for collisions between teams only if needed
          if (needsUpdate) {
            checkTeamCollisions();
            
            // Batch DOM updates for better performance
            teamBouncers.forEach(bouncer => {
              if (bouncer.visible) {
                updateBouncerPosition(bouncer);
              }
            });
          }
          
          lastFrameTime = currentTime;
        }
        
        animationFrameId = requestAnimationFrame(animate);
      }
      
      animate(performance.now());
    }
    
    // Stop bouncing animation
    function stopBouncing() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }
    
    // Update bouncer team color
    function updateBouncerTeamColor(teamNum, color) {
      const bouncer = teamBouncers.find(b => b.teamNum === teamNum);
      if (bouncer) {
        bouncer.element.style.background = color;
      }
    }
    
    // Update bouncer team name
    function updateBouncerTeamName(teamNum, name) {
      const bouncer = teamBouncers.find(b => b.teamNum === teamNum);
      if (bouncer) {
        const nameElement = bouncer.element.querySelector('.team-bouncer-name');
        if (nameElement) {
          nameElement.textContent = name;
        }
      }
    }
    
    // Smooth winner animation to center
    function animateWinnerToCenter(teamNum, callback) {
      const winnerBouncer = teamBouncers.find(b => b.teamNum === teamNum);
      if (!winnerBouncer) {
        console.log('âŒ Winner bouncer not found for team:', teamNum);
        if (callback) callback();
        return;
      }
      
      console.log('ðŸŽ‰ WINNER! Starting smooth animation for team', teamNum);
      winnerAnimating = true;
      
      const element = winnerBouncer.element;
      const config = getBouncingConfig();
      
      // Use the bouncer's actual position data (not getBoundingClientRect)
      const currentX = winnerBouncer.x;
      const currentY = winnerBouncer.y;
      
      console.log('ðŸ“ Current bouncer position:', { x: currentX, y: currentY });
      
      // Calculate screen center for the main circle
      const screenCenterX = window.innerWidth / 2;
      const screenCenterY = window.innerHeight / 2;
      
      // Calculate final position (center the team in the screen center)
      const finalX = screenCenterX - config.teamSize / 2;
      const finalY = screenCenterY - config.teamSize / 2;
      
      console.log('ðŸŽ¯ Target center position:', { x: finalX, y: finalY });
      
      // Remove from bouncing system immediately
      winnerBouncer.visible = false;
      
      // Set up element for smooth animation using current position
      element.style.position = 'absolute';
      element.style.left = '0px';
      element.style.top = '0px';
      element.style.zIndex = '1000';
      element.style.transition = 'none';
      
      // Start from current bouncing position
      element.style.transform = `translate(${currentX}px, ${currentY}px) scale(1)`;
      element.dataset.scale = '1';
      
      // Force reflow
      element.offsetHeight;
      
      // Add celebration effect at current position
      element.classList.add('winner-celebrating');
      
      setTimeout(() => {
        // Remove celebration and start smooth movement
        element.classList.remove('winner-celebrating');
        element.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)'; // Smooth easing
        
        // Force reflow
        element.offsetHeight;
        
        // Animate smoothly to center with scale down
        element.style.transform = `translate(${finalX}px, ${finalY}px) scale(0.7)`;
        element.dataset.scale = '0.7';
        
        console.log('ðŸš€ Smooth animation to center started');
        
        // Complete animation
        setTimeout(() => {
          element.classList.add('winner-positioned');
          winnerAnimating = false;
          console.log('ðŸ† Winner smoothly positioned at center');
          
          if (callback) callback();
        }, 800); // Match the 0.8s animation
        
      }, 200); // Shorter celebration time
    }
    

    
    // Simple animation from center back to bouncing
    function animateWinnerFromCenter(teamNum, callback) {
      const winnerBouncer = teamBouncers.find(b => b.teamNum === teamNum);
      if (!winnerBouncer) {
        console.log('Winner bouncer not found for reset:', teamNum);
        if (callback) callback();
        return;
      }
      
      console.log('ðŸš€ Moving winner back to bouncing:', teamNum);
      winnerAnimating = true;
      
      // Get new random position
      const newPos = getRandomPosition();
      const config = getBouncingConfig();
      
      // Set up element for exit animation
      const element = winnerBouncer.element;
      element.classList.remove('winner-positioned');
      element.style.position = 'absolute'; // Change back to absolute for bouncing
      element.style.left = '0px';
      element.style.top = '0px';
      element.style.transition = 'all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
      element.style.zIndex = '10';
      element.dataset.scale = '1';
      
      // Animate to new position using transform
      element.style.transform = `translate(${newPos.x}px, ${newPos.y}px) scale(1)`;
      
      // Update bouncer data with billiard ball return velocity
      winnerBouncer.x = newPos.x;
      winnerBouncer.y = newPos.y;
      
      // Clean directional velocity for return
      const returnAngle = Math.random() * Math.PI * 2;
      const returnSpeed = config.speed + Math.random() * (config.maxSpeed - config.speed) * 0.3;
      winnerBouncer.vx = Math.cos(returnAngle) * returnSpeed;
      winnerBouncer.vy = Math.sin(returnAngle) * returnSpeed;
      
      setTimeout(() => {
        // Return to bouncing system
        resetTeamElement(winnerBouncer);
        winnerAnimating = false;
        console.log('ðŸŽ¯ Winner returned to bouncing!');
        if (callback) callback();
      }, 600);
    }

    // Get team name
    function getTeamName(num) {
      const saved = localStorage.getItem(`team${num}Name`);
      return saved && saved.trim() ? saved.trim() : `Team ${num}`;
    }
    
    // Connection functions
    async function connectSerial() {
      try {
        if (!('serial' in navigator)) {
          alert('Web Serial API is not supported in this browser. Please use Chrome or Edge.');
          return;
        }
        
        // Check if we're already trying to connect
        if (isConnected) {
          console.log('âš ï¸ Already connected - disconnect first');
          if (confirm('Already connected to a device. Disconnect, unpair, and reconnect?')) {
            await disconnectSerial(true); // Full disconnect with unpair
            // Wait a moment before reconnecting
            await new Promise(resolve => setTimeout(resolve, 1000));
          } else {
            return;
          }
        }
        
        // Clean initial state
        isConnected = false;
        isDeviceReady = false;
        connectionHealth = 0;
        lastDataReceived = 0;
        readLoopActive = false;
        
        console.log('ðŸ”Œ Starting fresh connection attempt...');
        
        console.log('ðŸ“‹ Available ports before selection:', await navigator.serial.getPorts());
        
        // Request port with better user guidance
        console.log('ðŸ”Œ Requesting serial port selection...');
        console.log('ðŸ’¡ Select your Arduino/ESP32 device from the popup');
        console.log('   Look for: "USB Serial", "Arduino", "ESP32", "CH340", "CP210x", etc.');
        
        port = await navigator.serial.requestPort();
        
        console.log('âœ… Port selected:', port);
        console.log('ðŸ“Š Port info:', {
          readable: !!port.readable,
          writable: !!port.writable
        });
        
        // Check if device is still connected after selection
        const portsAfterSelection = await navigator.serial.getPorts();
        const portStillExists = portsAfterSelection.includes(port);
        console.log('ðŸ” Port still exists after selection:', portStillExists);
        
        if (!portStillExists) {
          throw new Error('Device was disconnected after selection. Please reconnect and try again.');
        }
        
        // Small delay to ensure port is ready (some systems need this)
        console.log('â³ Waiting for port to stabilize...');
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Try different baud rates if initial connection fails
        const baudRates = [9600, 115200, 57600, 38400, 19200];
        let connected = false;
        let lastError = null;
        
        for (const baudRate of baudRates) {
          try {
            console.log(`ðŸ”Œ Attempting connection at ${baudRate} baud...`);
            await port.open({ 
              baudRate: baudRate,
              dataBits: 8,
              stopBits: 1,
              parity: 'none',
              flowControl: 'none'
            });
            
            // Wait for Arduino to initialize
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Set up writer for outgoing data FIRST
            serialWriter = port.writable.getWriter();
            
            // Set up reader for incoming data
            const textDecoder = new TextDecoderStream();
            const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
            reader = textDecoder.readable.getReader();
            
            console.log('ðŸ“– Reader and writer setup complete');
            
            isConnected = true;
            isDeviceReady = false; // Not ready until we confirm communication
            connectionHealth = 0;
            // Don't change dot color yet - wait for device response
            connectionModal.classList.remove('visible');
            
            console.log(`ðŸ”— Serial port opened at ${baudRate} baud - verifying device...`);
            console.log('ðŸ“‹ Connection state:', { isConnected, isDeviceReady, hasReader: !!reader, hasWriter: !!serialWriter });
            
            // Update status based on current state (should be yellow - connected but not ready)
            updateConnectionStatus();
            
            // Verify connection stability before starting read loop
            setTimeout(async () => {
              console.log('ðŸ” Verifying connection stability...');
              
              // Check if port is still accessible
              try {
                const stillAccessible = port && port.readable && port.writable;
                console.log('ðŸ“Š Port accessibility check:', stillAccessible);
                
                if (!stillAccessible) {
                  console.error('âŒ Port no longer accessible - aborting connection');
                  handleDeviceLost();
                  return;
                }
                
                // Wait a bit more to ensure stability
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Start reading if still stable
                if (isConnected && port) {
                  console.log('ðŸš€ Starting read loop...');
                  readLoop();
                  
                  // Test communication after read loop starts
                  setTimeout(() => {
                    if (isConnected && !isDeviceReady) {
                      console.log('ðŸ§ª Testing Arduino communication...');
                      testDeviceConnection();
                    }
                  }, 1000);
                }
                
              } catch (error) {
                console.error('âŒ Stability check failed:', error);
                handleDeviceLost();
              }
            }, 500);
            
            connected = true;
            break;
            
          } catch (baudError) {
            lastError = baudError;
            console.log(`âŒ Failed at ${baudRate} baud:`, baudError.message);
            
            // Close port if it was opened
            try {
              await port.close();
            } catch (e) {
              // Ignore close errors
            }
            
            // Wait before trying next baud rate
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        }
        
        if (!connected) {
          // Provide specific help for "Failed to open serial port" error
          if (lastError && lastError.message.includes('Failed to open serial port')) {
            const helpMessage = `
âŒ SERIAL PORT ACCESS DENIED

Common causes and solutions:

ðŸ” MOST LIKELY CAUSES:
1. Arduino IDE Serial Monitor is open (CLOSE IT!)
2. Another browser tab has the port open
3. Device was unplugged after selection

ðŸ› ï¸ TROUBLESHOOTING STEPS:
1. Close Arduino IDE completely (not just Serial Monitor)
2. Close other browser tabs using serial devices
3. Unplug and reconnect your Arduino/ESP32
4. Try a different USB port
5. Check if device shows up in system (Device Manager on Windows)
6. Try a different USB cable

ðŸ’¡ QUICK FIX:
â€¢ Windows: Check Device Manager â†’ Ports (COM & LPT)
â€¢ Mac: Run 'ls /dev/cu.*' in Terminal
â€¢ Linux: Run 'ls /dev/ttyUSB* /dev/ttyACM*'

The port should appear when device is connected.`;
            
            console.error(helpMessage);
            alert('Serial Port Access Denied!\n\nMost likely cause: Arduino IDE Serial Monitor is open.\n\n1. Close Arduino IDE completely\n2. Unplug and reconnect Arduino\n3. Try connecting again\n\nCheck console (F12) for detailed troubleshooting guide.');
            throw new Error('Serial port access denied - see console for help');
          }
          
          throw lastError || new Error('All baud rates failed');
        }
        
      } catch (err) {
        console.error('Connection error:', err);
        statusDot.className = 'status-dot';
        connectionModal.classList.remove('visible');
        
        let errorMessage = '';
        
        if (err.name === 'NotFoundError') {
          console.log('ðŸš« User cancelled device selection');
          return; // Don't show error for user cancellation
        } else if (err.name === 'NetworkError' || err.message.includes('Failed to open serial port')) {
          errorMessage = `Arduino Connection Failed!

Troubleshooting Steps:
1. Make sure your Arduino/ESP32 is properly connected via USB
2. Check that no other programs (like Arduino IDE Serial Monitor) are using the port
3. Try uploading the Arduino code again
4. Restart your Arduino/ESP32 device
5. Try a different USB cable or port

Technical Error: ${err.message || 'Port access denied'}

The system will continue to work in simulation mode. Press keys 1-6 to test.`;
        } else if (err.name === 'InvalidStateError') {
          errorMessage = `Port Already in Use!

The serial port is already open in another tab or application.
Please close other connections and try again.

Note: Make sure Arduino IDE Serial Monitor is closed.`;
        } else {
          errorMessage = `Connection Error: ${err.message || 'Unknown error'}

Please check:
- Arduino is connected and powered
- Correct Arduino code is uploaded
- USB cable is working properly
- No other applications are using the serial port

The system will work in simulation mode.`;
        }
        
        if (errorMessage) {
          alert(errorMessage);
        }
      }
    }
    
    // Robust serial read with improved message parsing
    let serialBuffer = '';
    let messageQueue = [];
    let isProcessingQueue = false;
    let readLoopActive = false;
    
    async function readLoop() {
      if (readLoopActive) {
        console.log('âš ï¸ Read loop already active, skipping...');
        return;
      }
      
      readLoopActive = true;
      console.log('ðŸ“– Starting robust serial read loop...');
      
      try {
        let readCount = 0;
        
        while (isConnected && reader) {
          try {
            const { value, done } = await reader.read();
            readCount++;
            
            if (readCount % 100 === 0) {
              console.log(`ðŸ“Š Read operations: ${readCount}, connected: ${isConnected}`);
            }
            
            if (done) {
              console.log('ðŸ“š Read stream ended');
              break;
            }
            
                          if (value) {
                console.log('ðŸ“¡ Raw data received:', JSON.stringify(value));
                
                // Update device health - we're receiving data!
                lastDataReceived = Date.now();
                connectionHealth = Math.min(100, connectionHealth + 10);
                
                // If this is the first data, mark device as ready
                if (!isDeviceReady) {
                  isDeviceReady = true;
                  console.log('âœ… Arduino device is now ready and responding!');
                  console.log('ðŸ’¡ Device management:');
                  console.log('  â€¢ Disconnect & unpair: Click connection button (recommended)');
                  console.log('  â€¢ Just disconnect: window.debugSerial.disconnect()');
                  updateConnectionStatus();
                }
                
                // Clean the incoming data and add to buffer
                const cleanValue = value.replace(/\r/g, ''); // Remove carriage returns
                serialBuffer += cleanValue;
                
                console.log('ðŸ“¦ Current buffer:', JSON.stringify(serialBuffer));
                
                // Process complete lines (split on newline)
                const lines = serialBuffer.split('\n');
                // Keep the last partial line in buffer
                serialBuffer = lines.pop() || '';
                
                // Queue complete lines for processing
                lines.forEach(line => {
                  const trimmed = line.trim();
                  if (trimmed && trimmed.length > 0) {
                    console.log('ðŸ” Raw line from Arduino:', JSON.stringify(trimmed));
                    messageQueue.push(trimmed);
                  }
                });
                
                // Process queue immediately for responsiveness
                if (!isProcessingQueue && messageQueue.length > 0) {
                  processMessageQueue();
                }
              } else {
              // No data available, small delay
              await new Promise(resolve => setTimeout(resolve, 10));
            }
            
          } catch (readError) {
            if (readError.name === 'NetworkError' && readError.message.includes('device has been lost')) {
              console.error('ðŸ”Œ Device lost during read operation!');
              handleDeviceLost();
              break; // Exit read loop immediately
            } else {
              console.error('âŒ Individual read error:', readError);
              // Reduce health on read errors but don't immediately disconnect
              connectionHealth = Math.max(0, connectionHealth - 10);
              updateConnectionStatus();
              await new Promise(resolve => setTimeout(resolve, 100));
            }
          }
        }
        
        console.log('ðŸ“– Read loop exited normally');
        
      } catch (error) {
        if (error.name === 'NetworkError' && error.message.includes('device has been lost')) {
          console.error('ðŸ”Œ Arduino device disconnected/lost!');
          handleDeviceLost();
        } else if (error.name !== 'NetworkError') {
          console.error('âŒ Read loop error:', error);
          // Reduce connection health on errors
          connectionHealth = Math.max(0, connectionHealth - 20);
          updateConnectionStatus();
        } else {
          console.log('ðŸ”Œ Connection closed normally');
        }
        
                  // Only set disconnected if it's a real disconnection
          if (error.name === 'NetworkError') {
            isConnected = false;
            isDeviceReady = false;
            connectionHealth = 0;
            updateConnectionStatus();
          }
      } finally {
        readLoopActive = false;
        console.log('ðŸ“– Read loop cleanup complete');
      }
    }
    
    // Robust message processing with improved error handling
    async function processMessageQueue() {
      if (isProcessingQueue) return;
      isProcessingQueue = true;
      
      try {
        while (messageQueue.length > 0) {
          const message = messageQueue.shift();
          console.log('âš¡ Processing queued message:', JSON.stringify(message));
          
          try {
            handleSerialData(message);
          } catch (error) {
            console.error('âŒ Error processing message:', message, 'Error:', error);
          }
          
          // Small delay between messages for stability
          if (messageQueue.length > 0) {
            await new Promise(resolve => setTimeout(resolve, 2));
          }
        }
      } catch (error) {
        console.error('âŒ Message queue processing error:', error);
      } finally {
        isProcessingQueue = false;
      }
    }
    
    // Handle device lost/disconnected
    function handleDeviceLost() {
      // Prevent multiple simultaneous calls
      if (!isConnected && !port) {
        console.log('ðŸ” Device already cleaned up, skipping...');
        return;
      }
      
      console.error('ðŸš¨ Arduino device has been lost/disconnected!');
      
      // Immediately update state
      const wasConnected = isConnected;
      isConnected = false;
      isDeviceReady = false;
      connectionHealth = 0;
      lastDataReceived = 0;
      readLoopActive = false;
      
      // Clean up connection objects thoroughly
      if (reader) {
        try {
          reader.cancel().catch(() => {}); // Ignore errors
          reader.releaseLock();
        } catch (e) {
          // Ignore errors during cleanup
        }
        reader = null;
      }
      
      if (serialWriter) {
        try {
          serialWriter.releaseLock();
        } catch (e) {
          // Ignore errors during cleanup
        }
        serialWriter = null;
      }
      
      if (port) {
        try {
          port.close();
        } catch (e) {
          // Ignore errors during cleanup
        }
        port = null;
      }
      
      // Update status after cleanup
      updateConnectionStatus();
      
      console.log('ðŸ§¹ Device cleanup completed');
      
      // Show user notification only if we were actually connected
      if (wasConnected) {
        setTimeout(() => {
          alert('Arduino device disconnected!\n\nPossible causes:\n1. USB cable unplugged\n2. Device powered off\n3. Driver issue\n\nTo reconnect:\n1. Check USB connection\n2. Close any other serial programs\n3. Click the connection button to reconnect');
        }, 500);
      }
    }
    
    // Test device connection and readiness
    async function testDeviceConnection() {
      if (!isConnected || !serialWriter) {
        console.log('âŒ Cannot test - no connection');
        return;
      }
      
      console.log('ðŸ§ª Testing device communication...');
      
      // Give initial health points during testing to show yellow
      connectionHealth = 25; // Enough to show yellow but not green
      updateConnectionStatus();
      
      try {
        // Send a reset command to test communication
        await queueSerialWrite('RESET\n');
        console.log('ðŸ“¤ Test command sent, waiting for response...');
        
        // Wait up to 5 seconds for device to respond
        const testTimeout = setTimeout(() => {
          if (!isDeviceReady) {
            console.log('âš ï¸ Device not responding - may not be ready');
            connectionHealth = 50; // Partial connection
            updateConnectionStatus();
          }
        }, 5000);
        
        // If device responds within timeout, testTimeout will be cleared by data reception
        setTimeout(() => clearTimeout(testTimeout), 5000);
        
      } catch (error) {
        console.error('âŒ Device test failed:', error);
        connectionHealth = 0;
        updateConnectionStatus();
      }
    }
    
    // Update status dot based on device readiness (primary indicator)
    function updateConnectionStatus() {
      const oldClass = statusDot.className;
      
      // Strict device readiness check
      if (isDeviceReady === true && connectionHealth >= 50 && isConnected === true && port && reader && serialWriter) {
        statusDot.className = 'status-dot connected'; // Green - device ready and working
      } else if (isConnected === true && connectionHealth > 0 && port) {
        statusDot.className = 'status-dot connecting'; // Yellow - connected but device not ready/responding
      } else {
        statusDot.className = 'status-dot'; // Red - not connected or no device response
      }
      
      const newColor = statusDot.className.includes('connected') ? 'GREEN' : 
                      statusDot.className.includes('connecting') ? 'YELLOW' : 'RED';
      
      if (oldClass !== statusDot.className) {
        console.log('ðŸ“Š Status changed:', oldClass, 'â†’', statusDot.className);
      }
      
      console.log('ðŸ“Š Status updated (device-focused):', {
        isConnected,
        isDeviceReady,
        connectionHealth,
        hasPort: !!port,
        hasReader: !!reader,
        hasWriter: !!serialWriter,
        dotColor: newColor
      });
    }
    
    // Monitor connection health periodically
    function startConnectionMonitor() {
      setInterval(() => {
        // Check if we think we're connected but port is gone
        if (isConnected && port) {
          try {
            // Check if port is still accessible
            if (!port.readable || !port.writable) {
              console.log('âš ï¸ Port no longer accessible - device may be lost');
              handleDeviceLost();
              return;
            }
          } catch (error) {
            console.log('âš ï¸ Port check failed - device may be lost:', error);
            handleDeviceLost();
            return;
          }
        }
        
        // Health monitoring for active devices
        if (isConnected && isDeviceReady) {
          const timeSinceLastData = Date.now() - lastDataReceived;
          
          // If no data for more than 30 seconds, reduce health
          if (timeSinceLastData > 30000) {
            connectionHealth = Math.max(0, connectionHealth - 5);
            console.log('âš ï¸ No data received recently, reducing connection health');
            updateConnectionStatus();
            
            // If health gets too low, assume device is lost
            if (connectionHealth <= 10) {
              console.log('ðŸ’€ Connection health critical - assuming device lost');
              handleDeviceLost();
            }
          }
        }
        
        // Debug status every 30 seconds when connected
        if (isConnected && Date.now() % 30000 < 5000) {
          console.log('ðŸ” Connection monitor check:', {
            isConnected,
            isDeviceReady,
            connectionHealth,
            hasPort: !!port,
            timeSinceData: lastDataReceived ? (Date.now() - lastDataReceived) / 1000 + 's' : 'never'
          });
        }
      }, 5000); // Check every 5 seconds
    }
    
    function handleSerialData(data) {
      console.log('ðŸ“¨ Processing message from Arduino:', JSON.stringify(data));
      
      // Clean up the data
      const cleanData = data.trim();
      if (!cleanData || cleanData.length === 0) {
        console.log('ðŸ“­ Ignoring empty message');
        return; // Ignore empty lines
      }
      
      // Advanced message validation and corruption handling
      
      // 1. Check for messages that are too long (likely concatenated)
      if (cleanData.length > 50) {
        console.log('âš ï¸ Message too long, likely concatenated:', cleanData.substring(0, 50) + '...');
        // Try to extract valid patterns from concatenated message
        tryExtractFromConcatenated(cleanData);
        return;
      }
      
      // 2. Handle WINNER messages (clean and corrupted)
      if (cleanData.includes('WINNER')) {
        return handleWinnerMessage(cleanData);
      }
      
      // 3. Handle RESET/READY messages (clean and corrupted)
      if (cleanData.includes('RESET') || cleanData.includes('READY')) {
        console.log('ðŸ”„ Processing RESET/READY message from Arduino');
        resetDisplay();
        return;
      }
      
      // 4. Handle TIMING messages (new format)
      if (cleanData.startsWith('TIMING:')) {
        const parts = cleanData.split(':');
        if (parts.length === 3) {
          const teamPart = parts[1]; // T1 or T2
          const timing = parts[2];   // microseconds
          console.log(`â±ï¸ Timing data - ${teamPart}: ${timing} microseconds`);
        } else {
          console.log('âŒ Invalid TIMING message format:', cleanData);
        }
        return;
      }
      
      // 5. Handle legacy debug/timing messages  
      if (cleanData.startsWith('DEBUG:') || cleanData.startsWith('INFO:') || 
          cleanData.startsWith('T1:') || cleanData.startsWith('T2:')) {
        console.log('ðŸ› Arduino debug/timing:', cleanData);
        return;
      }
      
      // 6. Check for exact clean messages
      if (cleanData === 'READY' || cleanData === 'RESET') {
        console.log('âœ… Clean control message:', cleanData);
        resetDisplay();
        return;
      }
      
      // 7. If we get here, it's an unknown message
      console.log('â“ Unknown message format:', cleanData);
    }
    
    function handleWinnerMessage(message) {
      console.log('ðŸ† Processing potential WINNER message:', message);
      
      // Try exact match first (cleanest case)
      if (message.startsWith('WINNER:')) {
        const parts = message.split(':');
        if (parts.length === 2) {
          const teamNum = parseInt(parts[1]);
          if (!isNaN(teamNum) && teamNum >= 1 && teamNum <= 6) {
            return acceptWinner(teamNum, 'clean');
          }
        }
        console.log('âŒ Clean WINNER message but invalid format:', message);
        return;
      }
      
      // Try to extract from corrupted message
      const winnerMatch = message.match(/WINNER:([1-6])/);
      if (winnerMatch) {
        const teamNum = parseInt(winnerMatch[1]);
        console.log('ðŸ”§ Extracted WINNER from corrupted message:', teamNum);
        return acceptWinner(teamNum, 'extracted');
      }
      
      // Check for partial WINNER (just "WINNER" or "WINNE" etc.)
      if (message.match(/WINN?E?R?$/i)) {
        console.log('âŒ Partial WINNER message detected but no team number:', message);
        return;
      }
      
      console.log('âŒ WINNER keyword found but could not extract team number:', message);
    }
    
    function acceptWinner(teamNum, source) {
      console.log(`ðŸ† ${source.toUpperCase()} WINNER message for team:`, teamNum);
      
      // Check if we can accept this winner
      if (currentWinner !== null) {
        console.log('âš ï¸ Winner already exists:', currentWinner, '- ignoring new winner:', teamNum);
        return;
      }
      
      console.log('âœ… Accepting winner:', teamNum);
      showWinner(teamNum);
    }
    
    function tryExtractFromConcatenated(message) {
      console.log('ðŸ”§ Trying to extract valid messages from concatenated data');
      
      // Look for WINNER patterns
      const winnerMatches = message.match(/WINNER:([1-6])/g);
      if (winnerMatches && winnerMatches.length > 0) {
        // Take the first valid winner
        const firstWinner = winnerMatches[0];
        const teamNum = parseInt(firstWinner.split(':')[1]);
        console.log('ðŸ”§ Extracted first WINNER from concatenated message:', teamNum);
        acceptWinner(teamNum, 'concatenated');
        return;
      }
      
      // Look for READY/RESET
      if (message.includes('READY') || message.includes('RESET')) {
        console.log('ðŸ”§ Extracted RESET/READY from concatenated message');
        resetDisplay();
        return;
      }
      
      console.log('âŒ Could not extract valid messages from concatenated data');
    }
    
    // Display functions
    function showWinner(teamNum) {
      console.log('ðŸ† showWinner called for team:', teamNum);
      currentWinner = teamNum;
      const name = getTeamName(teamNum);
      const color = getTeamColor(teamNum);
      
            console.log('ðŸŽ¯ Starting EXCITING WINNER animation!');
      
      // Stop bouncing immediately and freeze other teams
      stopBouncing();
      teamBouncers.forEach(bouncer => {
        if (bouncer.teamNum !== teamNum) {
          bouncer.visible = false; // Lock out other teams immediately
        }
      });
      
      // Only the winning team gets to animate!
      animateWinnerToCenter(teamNum, () => {
        console.log('ðŸŽ‰ Winner reached the center!');
        
        // Winner made it - now trigger celebration effects
        triggerCelebrationEffects();
        
        // Show team name with delay for dramatic effect
        setTimeout(() => {
          teamName.textContent = name;
          teamName.classList.add('visible');
        }, 200);
        
        // Update circle with team color
        circleContent.textContent = teamNum;
        circleContent.className = 'circle-content winner-number';
        mainCircle.classList.add('winner');
        mainCircle.style.background = `linear-gradient(135deg, ${color} 0%, ${adjustColorBrightness(color, -20)} 50%, ${adjustColorBrightness(color, -40)} 100%)`;
        
        // Show reset button with delay
        setTimeout(() => {
          resetBtn.classList.add('visible');
        }, 600);
      });
    }
    
    function triggerCelebrationEffects() {
      // Screen flash effect
      const screenFlash = document.getElementById('screenFlash');
      screenFlash.classList.add('active');
      setTimeout(() => {
        screenFlash.classList.remove('active');
      }, 600);
      
      // Create celebration particles
      createCelebrationParticles();
      
      // Create confetti
      setTimeout(createConfetti, 200);
    }
    
    function createCelebrationParticles() {
      const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
      
      for (let i = 0; i < 12; i++) {
        const particle = document.createElement('div');
        particle.className = 'celebration-particle';
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        
        // Position around the circle
        const angle = (i / 12) * 360;
        const radius = 120;
        const x = Math.cos(angle * Math.PI / 180) * radius;
        const y = Math.sin(angle * Math.PI / 180) * radius;
        
        particle.style.left = '50%';
        particle.style.top = '50%';
        particle.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
        
        mainCircle.appendChild(particle);
        
        // Trigger animation
        setTimeout(() => {
          particle.classList.add('burst');
        }, i * 50);
        
        // Remove particle after animation
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        }, 1200 + i * 50);
      }
    }
    
    function createConfetti() {
      const container = document.querySelector('.main-content');
      const colors = ['#FFD700', '#FFA500', '#FF6B6B', '#4ECDC4', '#45B7D1'];
      
      for (let i = 0; i < 20; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.background = `linear-gradient(45deg, ${colors[Math.floor(Math.random() * colors.length)]}, ${colors[Math.floor(Math.random() * colors.length)]})`;
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.top = '-20px';
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        
        container.appendChild(confetti);
        
        // Trigger animation
        setTimeout(() => {
          confetti.classList.add('fall');
        }, 10);
        
        // Remove confetti after animation
        setTimeout(() => {
          if (confetti.parentNode) {
            confetti.parentNode.removeChild(confetti);
          }
        }, 2500);
      }
    }
    
    function resetDisplay() {
      console.log('ðŸ”„ Reset display called, currentWinner:', currentWinner, 'winnerAnimating:', winnerAnimating);
      
      // Stop all animation immediately for responsive reset
      stopBouncing();
      
      // Force clear all states
      const hadWinner = currentWinner !== null;
      const winnerTeamNum = currentWinner;
      currentWinner = null; // Clear immediately for fresh start
      winnerAnimating = false; // Force stop any ongoing animations
      
      // Always perform immediate UI reset for consistency
      teamName.classList.remove('visible');
      teamName.textContent = '';
      circleContent.textContent = 'â€¢';
      circleContent.className = 'circle-content waiting';
      mainCircle.classList.remove('winner');
      mainCircle.style.background = '';
      resetBtn.classList.remove('visible');
      
      // Clean up all celebration effects immediately
      cleanupCelebrationEffects();
      
      // Reset all team elements to clean state
      teamBouncers.forEach(bouncer => {
        resetTeamElement(bouncer);
      });
      
      // For smoother reset, use a shorter delay before starting bouncing
      setTimeout(() => {
        startBouncing();
        console.log('âœ… Fresh round started - all teams bouncing');
      }, 100); // Reduced delay for more responsive feel
      
      console.log('ðŸŽ® System ready for next round!');
    }
    
    // Helper function to adjust color brightness
    function adjustColorBrightness(color, percent) {
      const num = parseInt(color.replace("#", ""), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }
    
    function cleanupCelebrationEffects() {
      // Remove any remaining particles
      const particles = document.querySelectorAll('.celebration-particle');
      particles.forEach(particle => {
        if (particle.parentNode) {
          particle.parentNode.removeChild(particle);
        }
      });
      
      // Remove any remaining confetti
      const confetti = document.querySelectorAll('.confetti');
      confetti.forEach(conf => {
        if (conf.parentNode) {
          conf.parentNode.removeChild(conf);
        }
      });
      
      // Stop screen flash if active
      const screenFlash = document.getElementById('screenFlash');
      screenFlash.classList.remove('active');
    }

    // Non-blocking serial write with queue
    let writeQueue = [];
    let isWriting = false;
    
    async function queueSerialWrite(data) {
      writeQueue.push(data);
      if (!isWriting) {
        processWriteQueue();
      }
    }
    
    async function processWriteQueue() {
      if (isWriting || !isConnected || !serialWriter) return;
      isWriting = true;
      
      try {
        while (writeQueue.length > 0 && isConnected) {
          const data = writeQueue.shift();
          const encoder = new TextEncoder();
          const encoded = encoder.encode(data);
          await serialWriter.write(encoded);
          
          // Small delay to prevent overwhelming Arduino
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      } catch (error) {
        console.error('âŒ Write queue error:', error);
      } finally {
        isWriting = false;
      }
    }
    
    // Send reset command (optimized)
    async function sendReset() {
      console.log('ðŸ”„ sendReset() called - checking connection modes...');
      console.log('   Socket connected:', typeof socket !== 'undefined' && socket && socket.connected);
      console.log('   Hardware connected:', isConnected && !!serialWriter);
      console.log('   Current winner:', currentWinner);
      
      // Always reset display first for immediate visual feedback
      resetDisplay();
      
      // Check if we're in dev server mode
      if (typeof socket !== 'undefined' && socket && socket.connected) {
        try {
          socket.emit('reset_buzzers');
          console.log('âœ… Reset sent to dev server');
        } catch (error) {
          console.error('âŒ Dev server reset error:', error);
        }
      } else if (isConnected && serialWriter) {
        // Real hardware mode with non-blocking write
        try {
          console.log('ðŸ“¤ Queuing RESET command to Arduino...');
          await queueSerialWrite('RESET\n');
          console.log('âœ… Reset command queued for Arduino hardware');
          
          // Give Arduino time to process and respond
          setTimeout(() => {
            console.log('â³ Waiting for Arduino READY confirmation...');
          }, 100);
          
        } catch (error) {
          console.error('âŒ Hardware reset error:', error);
          console.log('ðŸ’¡ Try disconnecting and reconnecting Arduino');
        }
      } else {
        // Standalone mode (no connection)
        console.log('âœ… Reset performed (standalone mode - no hardware connected)');
      }
    }

    // Settings functions
    function resetAllSettings() {
      // Reset team names and colors to default
      for (let i = 1; i <= 6; i++) {
        localStorage.removeItem(`team${i}Name`);
        localStorage.removeItem(`team${i}Color`);
        
        // Update UI
        const nameInput = document.getElementById(`team${i}Input`);
        const colorInput = document.getElementById(`team${i}Color`);
        if (nameInput) nameInput.value = '';
        if (colorInput) colorInput.value = defaultTeamColors[i];
        
        // Update bouncing system
        updateBouncerTeamName(i, `Team ${i}`);
        updateBouncerTeamColor(i, defaultTeamColors[i]);
      }
      
      console.log('ðŸ”„ All settings reset to default');
    }
    
    function saveSettings() {
      // Force save all current values (already saved on change, but provides feedback)
      settingsModal.classList.remove('visible');
      console.log('ðŸ’¾ Settings saved successfully');
      
      // Visual feedback
      const saveBtn = document.getElementById('saveSettings');
      const originalText = saveBtn.textContent;
      saveBtn.textContent = 'âœ… Saved!';
        setTimeout(() => {
        saveBtn.textContent = originalText;
      }, 1500);
    }

    // Event listeners
    connectDeviceBtn.addEventListener('click', connectSerial);
    cancelConnect.addEventListener('click', () => {
      connectionModal.classList.remove('visible');
    });

    // Close connection modal when clicking backdrop
    connectionModal.addEventListener('click', (e) => {
      if (e.target === connectionModal) {
        connectionModal.classList.remove('visible');
      }
    });

    settingsBtn.addEventListener('click', () => {
      settingsModal.classList.add('visible');
    });

    closeSettings.addEventListener('click', () => {
      settingsModal.classList.remove('visible');
    });

    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.classList.remove('visible');
      }
    });

    resetBtn.addEventListener('click', sendReset);

    // Settings event listeners
    document.addEventListener('click', (e) => {
      if (e.target && e.target.id === 'resetAllSettings') {
        if (confirm('Reset all team names and colors to default? This cannot be undone.')) {
          resetAllSettings();
        }
      }
      if (e.target && e.target.id === 'saveSettings') {
        saveSettings();
      }
    });

    // Keyboard simulation for testing
    function simulateKeyboardBuzzer(teamNum) {
      console.log(`ðŸŽ® Keyboard simulation triggered for Team ${teamNum}`);
      console.log(`   Current winner state: ${currentWinner}`);
      console.log(`   Socket connected: ${typeof socket !== 'undefined' && socket && socket.connected}`);
      console.log(`   Hardware connected: ${isConnected}`);
      
      // Check current winner state first
      if (currentWinner !== null) {
        console.log(`âŒ Keyboard simulation: Team ${teamNum} buzzed (too late, Team ${currentWinner} already won)`);
        return;
      }
      
      // Check if we're in dev server mode (socket exists)
      if (typeof socket !== 'undefined' && socket && socket.connected) {
        // Send simulation event to dev server
        console.log(`ðŸ“¤ Sending simulate_buzzer to dev server for Team ${teamNum}`);
        try {
          socket.emit('simulate_buzzer', {team: teamNum});
          console.log(`âœ… Keyboard simulation: Team ${teamNum} buzzer sent to dev server`);
        } catch (error) {
          console.error(`âŒ Socket error for Team ${teamNum}:`, error);
          // Fallback to direct simulation
          console.log(`ðŸ”„ Falling back to direct simulation for Team ${teamNum}`);
          showWinner(teamNum);
        }
      } else {
        // Direct simulation for standalone mode
        console.log(`âœ… Keyboard simulation: Team ${teamNum} buzzer (direct mode)`);
        showWinner(teamNum);
      }
    }

    // Keyboard event listener for testing
    document.addEventListener('keydown', (event) => {
      // Only respond to number keys 1-6 and only when no modal is open
      const key = event.key;
      const isModalOpen = settingsModal.classList.contains('visible') || 
                         connectionModal.classList.contains('visible');
      
      if (!isModalOpen && key >= '1' && key <= '6') {
        event.preventDefault(); // Prevent any default behavior
        const teamNum = parseInt(key);
        simulateKeyboardBuzzer(teamNum);
        
        // Visual feedback - briefly highlight the connection button
        connectionBtn.style.transform = 'scale(0.95)';
      setTimeout(() => {
          connectionBtn.style.transform = '';
      }, 100);
      }
      
      // Reset with 'R' key
      if (!isModalOpen && (key === 'r' || key === 'R')) {
        event.preventDefault();
        
        // Use the same reset function as the button for consistency
        sendReset();
        console.log('Keyboard reset triggered');
        
        // Visual feedback
        if (resetBtn.classList.contains('visible')) {
          resetBtn.style.transform = 'translateY(0) scale(0.9)';
          setTimeout(() => {
            resetBtn.style.transform = '';
          }, 100);
        } else {
          // If reset button isn't visible, animate the connection button briefly
          connectionBtn.style.transform = 'scale(0.95)';
          setTimeout(() => {
            connectionBtn.style.transform = '';
          }, 100);
        }
      }
    });

    // Debug functions (available in console)
    window.debugSerial = {
      status: () => {
        console.log('ðŸ” Serial Debug Status:');
        console.log('  isConnected:', isConnected);
        console.log('  isDeviceReady:', isDeviceReady);
        console.log('  connectionHealth:', connectionHealth);
        console.log('  lastDataReceived:', new Date(lastDataReceived).toLocaleTimeString());
        console.log('  hasPort:', !!port);
        console.log('  hasReader:', !!reader);
        console.log('  hasWriter:', !!serialWriter);
        console.log('  readLoopActive:', readLoopActive);
        console.log('  serialBuffer:', JSON.stringify(serialBuffer));
        console.log('  messageQueue length:', messageQueue.length);
        console.log('  isProcessingQueue:', isProcessingQueue);
        console.log('  statusDot class:', statusDot.className);
      },
      
      testRead: async () => {
        if (!reader) {
          console.log('âŒ No reader available');
          return;
        }
        console.log('ðŸ§ª Manual read test...');
        try {
          const { value, done } = await reader.read();
          console.log('ðŸ“¡ Manual read result:', { value: JSON.stringify(value), done });
        } catch (error) {
          console.error('âŒ Manual read error:', error);
        }
      },
      
      restartRead: () => {
        console.log('ðŸ”„ Restarting read loop...');
        readLoopActive = false;
        if (isConnected && reader) {
          setTimeout(() => readLoop(), 100);
        }
      },
      
      sendTest: () => {
        console.log('ðŸ“¤ Sending test command to Arduino...');
        queueSerialWrite('TEST\n');
      },
      
      clearBuffer: () => {
        serialBuffer = '';
        messageQueue = [];
        console.log('ðŸ§¹ Serial buffer and queue cleared');
      },
      
      checkPorts: async () => {
        if (!('serial' in navigator)) {
          console.log('âŒ Web Serial API not supported');
          return;
        }
        
        try {
          const ports = await navigator.serial.getPorts();
          console.log('ðŸ” Available serial ports:');
          if (ports.length === 0) {
            console.log('  No ports available');
            console.log('ðŸ’¡ This might mean:');
            console.log('  1. No devices connected');
            console.log('  2. Devices not granted permission yet');
            console.log('  3. Drivers not installed');
          } else {
            ports.forEach((port, index) => {
              console.log(`  Port ${index + 1}:`, port);
            });
          }
        } catch (error) {
          console.error('âŒ Error checking ports:', error);
        }
      },
      
      diagnoseConnection: () => {
        console.log('ðŸ¥ CONNECTION DIAGNOSIS:');
        console.log('='.repeat(50));
        console.log('BROWSER SUPPORT:');
        console.log('  Web Serial API:', 'serial' in navigator ? 'âœ… Supported' : 'âŒ Not supported');
        console.log('  Browser:', navigator.userAgent.includes('Chrome') ? 'Chrome âœ…' : 'Other browser âš ï¸');
        console.log('');
        console.log('CONNECTION STATE:');
        console.log('  isConnected:', isConnected ? 'âœ…' : 'âŒ');
        console.log('  isDeviceReady:', isDeviceReady ? 'âœ…' : 'âŒ');
        console.log('  connectionHealth:', connectionHealth);
        console.log('  hasPort:', !!port ? 'âœ…' : 'âŒ');
        console.log('  hasReader:', !!reader ? 'âœ…' : 'âŒ');
        console.log('  hasWriter:', !!serialWriter ? 'âœ…' : 'âŒ');
        console.log('');
        console.log('COMMON ISSUES:');
        console.log('  1. Arduino IDE open â†’ Close it completely');
        console.log('  2. Other browser tabs using serial â†’ Close them');
        console.log('  3. Device unplugged â†’ Reconnect USB cable');
        console.log('  4. Wrong drivers â†’ Check Device Manager/System Info');
        console.log('  5. Permission denied â†’ Try different browser/restart');
        console.log('');
        console.log('NEXT STEPS:');
        console.log('  â€¢ Run: window.debugSerial.checkPorts()');
        console.log('  â€¢ Check system device list');
        console.log('  â€¢ Try different USB port/cable');
        console.log('='.repeat(50));
      },
      
      disconnect: () => {
        console.log('ðŸ”Œ Disconnecting device (keeping paired)...');
        disconnectSerial(false);
      },
      
      disconnectAndForget: () => {
        console.log('ðŸ§¹ Disconnecting and forgetting device...');
        disconnectSerial(true);
      },
      
      forgetDevice: async () => {
        // Alias for disconnectAndForget - same functionality
        window.debugSerial.disconnectAndForget();
      },
      
      listPairedDevices: async () => {
        try {
          const ports = await navigator.serial.getPorts();
          console.log('ðŸ“‹ Paired devices in browser:');
          if (ports.length === 0) {
            console.log('  No devices paired');
          } else {
            ports.forEach((port, index) => {
              console.log(`  Device ${index + 1}:`, port);
            });
            console.log('');
            console.log('ðŸ’¡ To unpair a device:');
            console.log('  1. Connect to it: Click connection button');
            console.log('  2. Unpair it: window.debugSerial.forgetDevice()');
            console.log('  OR visit: chrome://settings/content/serialPorts');
          }
        } catch (error) {
          console.error('âŒ Error listing paired devices:', error);
        }
      }
    };
    
    // Initialize connection status
    function initializeConnectionStatus() {
      // Ensure device status is properly set on load
      isConnected = false;
      isDeviceReady = false;
      connectionHealth = 0;
      lastDataReceived = 0;
      readLoopActive = false;
      
      // Force red dot on initialization
      statusDot.className = 'status-dot'; // Red by default (no device)
      updateConnectionStatus(); // Double-check with proper logic
      
      console.log('ðŸ”— Device status initialized:', { 
        isConnected, 
        isDeviceReady, 
        connectionHealth,
        dotColor: statusDot.className.includes('connected') ? 'GREEN' : 
                 statusDot.className.includes('connecting') ? 'YELLOW' : 'RED'
      });
      
      // Check if Web Serial API is supported
      if (!('serial' in navigator)) {
        console.warn('âš ï¸ Web Serial API not supported in this browser');
        connectionBtn.title = 'Web Serial not supported - use Chrome or Edge';
      } else {
        console.log('âœ… Web Serial API is supported');
        connectionBtn.title = 'Click to connect Arduino device';
      }
      
      console.log('ðŸ› ï¸ Debug commands available:');
      console.log('  window.debugSerial.status() - Check connection state');
      console.log('  window.debugSerial.diagnoseConnection() - Full diagnosis');
      console.log('  window.debugSerial.checkPorts() - List available ports');
      console.log('  window.debugSerial.listPairedDevices() - Show paired devices');
      console.log('  window.debugSerial.disconnect() - Disconnect only (keep paired)');
      console.log('  window.debugSerial.disconnectAndForget() - Disconnect & unpair');
      console.log('  window.debugSerial.restartRead() - Restart reading');
      console.log('  window.debugSerial.sendTest() - Send test command');
    }

    // Disconnect function with option to forget device
    async function disconnectSerial(forgetDevice = false) {
      try {
        console.log('ðŸ”Œ Disconnecting from Arduino...');
        
        // Store port reference for potential forgetting
        const portToForget = port;
        
        if (reader) {
          try {
            await reader.cancel();
            await reader.releaseLock();
          } catch (e) {
            console.log('Reader cleanup completed');
          }
          reader = null;
        }
        
        if (serialWriter) {
          try {
            await serialWriter.releaseLock();
          } catch (e) {
            console.log('Writer cleanup completed');
          }
          serialWriter = null;
        }
        
        if (port) {
          try {
            await port.close();
            console.log('âœ… Port closed successfully');
          } catch (e) {
            console.log('Port close completed');
          }
        }
        
        // Forget device from browser if requested
        if (forgetDevice && portToForget) {
          try {
            await portToForget.forget();
            console.log('ðŸ§¹ Device unpaired from browser successfully');
          } catch (e) {
            console.log('âš ï¸ Could not forget device:', e.message);
          }
        }
        
        port = null;
        
        // Reset all connection state
        isConnected = false;
        isDeviceReady = false;
        connectionHealth = 0;
        lastDataReceived = 0;
        readLoopActive = false;
        updateConnectionStatus();
        
        const actionMsg = forgetDevice ? 'disconnected and unpaired' : 'disconnected';
        console.log(`âœ… Arduino ${actionMsg} successfully`);
        
      } catch (error) {
        console.error('âŒ Error during disconnect:', error);
        // Force reset connection state even if there was an error
        isConnected = false;
        isDeviceReady = false;
        connectionHealth = 0;
        lastDataReceived = 0;
        readLoopActive = false;
        updateConnectionStatus();
        reader = null;
        serialWriter = null;
        port = null;
      }
    }

    // Add disconnect button functionality to connection button
    function updateConnectionButton() {
      connectionBtn.addEventListener('click', () => {
        console.log('ðŸ”— Connection button clicked, isConnected:', isConnected);
        
        if (isConnected) {
          // If connected, fully disconnect and forget device to prevent errors
          const choice = confirm('Disconnect and unpair Arduino device?\n\n' +
                               'This will:\n' +
                               'â€¢ Close the connection\n' +
                               'â€¢ Remove device from browser\'s paired list\n' +
                               'â€¢ Prevent connection conflicts\n\n' +
                               'You\'ll need to select the device again next time.');
          
          if (choice) {
            console.log('ðŸ§¹ User requested full disconnect and unpair');
            disconnectSerial(true); // Full disconnect with forget
          }
        } else {
          // If not connected, show connection modal
          console.log('ðŸ“± Opening connection modal');
          connectionModal.classList.add('visible');
        }
      });
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      initializeConnectionStatus();
      updateConnectionButton();
      initializeTeamInputs();
      initializeBouncingSystem();
      resetDisplay();
      startConnectionMonitor(); // Start monitoring connection health
      
      // Show keyboard shortcuts info in console
      console.log('ðŸš€ EXCITING Quiz Buzzer with SPECTACULAR Winner Staging!');
      console.log('ðŸŽ® Keyboard Shortcuts Available:');
      console.log('  Keys 1-6: Simulate team buzzer presses');
      console.log('  Key R: Reset system (works in all modes)');
      console.log('  Note: Shortcuts work when no modal is open');
      console.log('ðŸŽ± REALISTIC BILLIARD BALL Physics!');
      console.log('  ðŸŽ¯ Center circle collision - precise contact detection');
      console.log('  ðŸ“ Teams bounce only when actually touching (no early collisions)');
      console.log('  âš¡ Realistic physics: 95% restitution, minimal friction, precise reflections');
      console.log('  ðŸ’¥ Contact-only collisions with momentum conservation');
      console.log('  ðŸŽ¨ Team name always visible on top (z-index: 1000)');
      console.log('  ðŸš€ Smooth winner animation - no jumping or position glitches');
      console.log('  ðŸŽ‰ SMOOTH WINNER Animation:');
      console.log('    â€¢ 0.2s celebration bounce at current position');
      console.log('    â€¢ 0.8s smooth glide to screen center (no jumping!)');  
      console.log('    â€¢ Immediate lockout of other teams (realistic!)');
      console.log('    â€¢ Winner smoothly scales down inside circle');
      console.log('    â€¢ Clean reset returns all teams to realistic bouncing');
      console.log('  âš¡ REALISTIC: Only the first team to buzz gets to animate!');
      console.log('  ðŸŒŸ Enhanced effects: Screen flash, confetti, particle burst');
      console.log('ðŸ“¡ Connection Status:', { isConnected, supportSerial: 'serial' in navigator });
      console.log('');
      console.log('ðŸ”Œ Arduino Connection Instructions:');
      console.log('  1. Connect your XIAO nRF52840 (or compatible) via USB');
      console.log('  2. Click the connection button (Wi-Fi icon) in top-left');
      console.log('  3. Select your Arduino device from the browser popup');
      console.log('  4. Status dot shows: ðŸ”´ Red=No Device, ðŸŸ¡ Yellow=Testing, ðŸŸ¢ Green=Device Ready');
      console.log('  5. Green dot means Arduino is responding and ready for buzzers');
      console.log('  6. Arduino will send WINNER:X messages when buzzers are pressed');
      console.log('  7. To disconnect: Click connection button again (fully unpairs device)');
      console.log('');
      console.log('âš¡ Expected Arduino Messages:');
      console.log('  â€¢ WINNER:1 through WINNER:6 - Team buzzer pressed');
      console.log('  â€¢ RESET or READY - Reset all buzzers');
      console.log('  â€¢ DEBUG: or INFO: - Debug information');
      console.log('');
      console.log('ðŸ› ï¸ DEBUGGING SERIAL ISSUES:');
      console.log('  Status Dot Colors (Device-Focused):');
      console.log('    ðŸ”´ Red = No device found or not responding');
      console.log('    ðŸŸ¡ Yellow = Device connected but testing/not ready');
      console.log('    ðŸŸ¢ Green = Device ready and working properly');
      console.log('  If you get "device has been lost" error:');
      console.log('  1. Check USB cable connection');
      console.log('  2. Try different USB port');
      console.log('  3. Reconnect Arduino and try again');
      console.log('  If you get "Failed to open serial port":');
      console.log('  1. Close Arduino IDE completely (most common cause)');
      console.log('  2. Unplug and reconnect Arduino device');
      console.log('  3. Try different USB port/cable');
      console.log('  4. Run: window.debugSerial.diagnoseConnection()');
      console.log('  To manage paired devices:');
      console.log('  1. List paired: window.debugSerial.listPairedDevices()');
      console.log('  2. Disconnect & unpair: Click connection button (recommended)');
      console.log('  3. Just disconnect: window.debugSerial.disconnect()');
      console.log('  If yellow but not green:');
      console.log('  1. Run: window.debugSerial.checkPorts()');
      console.log('  2. Run: window.debugSerial.status()');
      console.log('  3. Check if Arduino is sending data in Serial Monitor');
      console.log('');
    });
  </script>
</body>
</html> 